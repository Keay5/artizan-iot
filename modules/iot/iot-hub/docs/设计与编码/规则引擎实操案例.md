## 规则引擎处理动态JSON数据的实操案例 

### 规则引擎处理动态 JSON 数据的实操案例

#### 场景背景

假设物联网设备通过自定义 Topic 上报**无固定物模型**的二进制数据，经`JavaScriptTslMessageParser`解析后生成**动态 JSON**（字段层级、类型不固定）。规则引擎需实现以下需求：

1. 提取 JSON 中`$.sensor.temp`（浮点型），判断是否 > 35℃，触发告警；
2. 提取 JSON 中`$.device.status`（字符串），判断是否包含 "error"，写入异常日志；
3. 提取 JSON 中`$.sensor.humidity[0]`（整型数组第一个元素），判断是否 < 20，转发到 Kafka。

#### 技术栈

- 解析层：`JavaScriptTslMessageParser`（Jint 执行 JS 脚本解析二进制→JSON）；
- 规则引擎层：C#/.NET + Newtonsoft.Json（JSONPath 提取字段）+ 动态表达式判断；
- 依赖包：`Newtonsoft.Json`（JSON 解析 / JSONPath）、`Jint`（JS 脚本执行）、`Microsoft.Extensions.Logging`（日志）。

------

### 步骤 1：定义核心模型

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using Microsoft.Extensions.Logging;

// 动态规则配置（用户可配置）
public class DynamicRule
{
    public string RuleId { get; set; } = Guid.NewGuid().ToString();
    public string RuleName { get; set; }          // 规则名称
    public string JsonPath { get; set; }          // JSONPath表达式
    public string Operator { get; set; }          // 运算符（>、<、contains等）
    public string Threshold { get; set; }         // 阈值（字符串存储，运行时转换）
    public List<RuleAction> Actions { get; set; } = new(); // 触发后动作
}

// 规则动作（告警/存储/转发）
public class RuleAction
{
    public string ActionType { get; set; } // alert/kafka/db
    public Dictionary<string, string> Config { get; set; } = new(); // 动作配置
}

// 规则执行结果
public class RuleExecuteResult
{
    public bool Success { get; set; }
    public List<string> TriggeredRules { get; set; } = new();
    public List<string> Errors { get; set; } = new();
}
```

------

### 步骤 2：实现动态 JSON 规则引擎

```csharp
public class DynamicJsonRuleEngine
{
    private readonly ILogger<DynamicJsonRuleEngine> _logger;
    private readonly List<DynamicRule> _rules;

    public DynamicJsonRuleEngine(ILogger<DynamicJsonRuleEngine> logger, List<DynamicRule> rules)
    {
        _logger = logger;
        _rules = rules ?? new List<DynamicRule>();
    }

    /// <summary>
    /// 核心方法：处理动态JSON数据
    /// </summary>
    /// <param name="dynamicJson">解析后的动态JSON字符串</param>
    public RuleExecuteResult Process(string dynamicJson)
    {
        var result = new RuleExecuteResult { Success = true };
        if (string.IsNullOrWhiteSpace(dynamicJson))
        {
            result.Success = false;
            result.Errors.Add("JSON数据为空");
            return result;
        }

        JObject jsonObj;
        try
        {
            jsonObj = JObject.Parse(dynamicJson);
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.Errors.Add($"JSON解析失败：{ex.Message}");
            _logger.LogError(ex, "JSON解析异常");
            return result;
        }

        // 遍历所有规则执行
        foreach (var rule in _rules)
        {
            try
            {
                // 1. JSONPath提取字段值
                var fieldToken = jsonObj.SelectToken(rule.JsonPath);
                if (fieldToken == null)
                {
                    result.Errors.Add($"规则[{rule.RuleName}]：JSONPath[{rule.JsonPath}]无匹配字段");
                    _logger.LogWarning("规则{0}字段不存在", rule.RuleName);
                    continue;
                }

                // 2. 自适应类型转换（JSON值→可计算类型）
                if (!TryConvertToken(fieldToken, out var fieldValue))
                {
                    result.Errors.Add($"规则[{rule.RuleName}]：字段类型不支持");
                    continue;
                }

                // 3. 规则条件判断
                if (EvaluateCondition(fieldValue, rule.Operator, rule.Threshold))
                {
                    // 4. 执行触发动作
                    ExecuteActions(rule, fieldValue);
                    result.TriggeredRules.Add(rule.RuleName);
                    _logger.LogInformation("规则[{0}]触发：{1} {2} {3}（当前值：{4}）",
                        rule.RuleName, rule.JsonPath, rule.Operator, rule.Threshold, fieldValue);
                }
            }
            catch (Exception ex)
            {
                result.Errors.Add($"规则[{rule.RuleName}]执行失败：{ex.Message}");
                _logger.LogError(ex, "规则{0}执行异常", rule.RuleName);
            }
        }

        return result;
    }

    /// <summary>
    /// JSON Token自适应类型转换
    /// </summary>
    private bool TryConvertToken(JToken token, out object value)
    {
        value = token.Type switch
        {
            JTokenType.Integer => token.Value<long>(),
            JTokenType.Float => token.Value<double>(),
            JTokenType.Boolean => token.Value<bool>(),
            JTokenType.String => token.Value<string>(),
            JTokenType.Array => token.ToObject<List<object>>(),
            _ => null
        };
        return value != null;
    }

    /// <summary>
    /// 规则条件判断（支持>、<、==、contains等）
    /// </summary>
    private bool EvaluateCondition(object fieldValue, string @operator, string threshold)
    {
        // 阈值转换为字段值相同类型
        if (!TryConvertThreshold(threshold, fieldValue.GetType(), out var thresholdValue))
        {
            _logger.LogWarning("阈值[{0}]无法转换为[{1}]类型", threshold, fieldValue.GetType().Name);
            return false;
        }

        return @operator.ToLower() switch
        {
            ">" => Comparer<object>.Default.Compare(fieldValue, thresholdValue) > 0,
            "<" => Comparer<object>.Default.Compare(fieldValue, thresholdValue) < 0,
            ">=" => Comparer<object>.Default.Compare(fieldValue, thresholdValue) >= 0,
            "<=" => Comparer<object>.Default.Compare(fieldValue, thresholdValue) <= 0,
            "==" => fieldValue.Equals(thresholdValue),
            "!=" => !fieldValue.Equals(thresholdValue),
            "contains" => fieldValue is string str && str.Contains(thresholdValue.ToString()),
            _ => throw new NotSupportedException($"不支持的运算符：{@operator}")
        };
    }

    /// <summary>
    /// 阈值类型转换（匹配字段值类型）
    /// </summary>
    private bool TryConvertThreshold(string threshold, Type targetType, out object thresholdValue)
    {
        thresholdValue = null;
        try
        {
            // 数组类型特殊处理（如threshold为"[10,20,30]"）
            if (targetType == typeof(List<object>))
            {
                thresholdValue = Newtonsoft.Json.JsonConvert.DeserializeObject<List<object>>(threshold);
                return true;
            }
            thresholdValue = Convert.ChangeType(threshold, targetType);
            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// 执行规则触发动作
    /// </summary>
    private void ExecuteActions(DynamicRule rule, object fieldValue)
    {
        foreach (var action in rule.Actions)
        {
            switch (action.ActionType.ToLower())
            {
                case "alert":
                    // 示例：发送告警（可对接钉钉/短信/邮件）
                    var alertTitle = action.Config["title"];
                    var alertContent = $"【{rule.RuleName}】触发：{rule.JsonPath} = {fieldValue}";
                    Console.WriteLine($"=== 告警 === {alertTitle}：{alertContent}");
                    break;

                case "kafka":
                    // 示例：转发到Kafka（实际需引入Confluent.Kafka包）
                    var kafkaTopic = action.Config["topic"];
                    var kafkaMsg = Newtonsoft.Json.JsonConvert.SerializeObject(new
                    {
                        RuleId = rule.RuleId,
                        Field = rule.JsonPath,
                        Value = fieldValue,
                        Time = DateTime.Now
                    });
                    Console.WriteLine($"=== 转发Kafka === Topic[{kafkaTopic}]：{kafkaMsg}");
                    break;

                case "db":
                    // 示例：写入数据库（实际需用EF Core/ADO.NET）
                    var table = action.Config["table"];
                    Console.WriteLine($"=== 写入数据库 === Table[{table}]：{rule.JsonPath} = {fieldValue}");
                    break;
            }
        }
    }
}
```

------

### 步骤 3：编写 JS 解析脚本（二进制→动态 JSON）

```javascript
// 解析脚本：rawDataToProtocolData（适配JavaScriptTslMessageParser）
function rawDataToProtocolData(rawData) {
    var uint8Array = new Uint8Array(rawData.length);
    for (var i = 0; i < rawData.length; i++) {
        uint8Array[i] = rawData[i] & 0xff;
    }
    var dataView = new DataView(uint8Array.buffer, 0);
    
    // 动态构造JSON（无固定物模型，字段层级/类型自定义）
    var jsonMap = {
        device: {
            id: "dev_001",
            status: "normal_error", // 字符串类型
            online: true
        },
        sensor: {
            temp: dataView.getFloat32(0), // 浮点型（字节0-3）
            humidity: [dataView.getInt8(4), 50, 60] // 整型数组（字节4为第一个元素）
        }
    };
    return jsonMap;
}
```

------

### 步骤 4：完整调用示例

```csharp
class Program
{
    static void Main(string[] args)
    {
        // 1. 初始化日志
        var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
        var ruleLogger = loggerFactory.CreateLogger<DynamicJsonRuleEngine>();

        // 2. 初始化解析器（二进制→动态JSON）
        var parser = new JavaScriptTslMessageParser(loggerFactory.CreateLogger<JavaScriptTslMessageParser>());

        // 3. 配置动态规则（模拟用户配置）
        var rules = new List<DynamicRule>
        {
            // 规则1：温度>35℃触发告警
            new DynamicRule
            {
                RuleName = "温度超标告警",
                JsonPath = "$.sensor.temp",
                Operator = ">",
                Threshold = "35",
                Actions = new List<RuleAction>
                {
                    new RuleAction
                    {
                        ActionType = "alert",
                        Config = new Dictionary<string, string>
                        {
                            { "title", "高温告警" },
                            { "level", "warning" }
                        }
                    }
                }
            },
            // 规则2：设备状态包含error写入数据库
            new DynamicRule
            {
                RuleName = "设备状态异常",
                JsonPath = "$.device.status",
                Operator = "contains",
                Threshold = "error",
                Actions = new List<RuleAction>
                {
                    new RuleAction
                    {
                        ActionType = "db",
                        Config = new Dictionary<string, string>
                        {
                            { "table", "device_error_log" },
                            { "conn", "Server=.;Database=IoT;Trusted_Connection=True;" }
                        }
                    }
                }
            },
            // 规则3：湿度<20转发到Kafka
            new DynamicRule
            {
                RuleName = "湿度异常转发",
                JsonPath = "$.sensor.humidity[0]",
                Operator = "<",
                Threshold = "20",
                Actions = new List<RuleAction>
                {
                    new RuleAction
                    {
                        ActionType = "kafka",
                        Config = new Dictionary<string, string>
                        {
                            { "topic", "sensor_humidity_exception" },
                            { "broker", "127.0.0.1:9092" }
                        }
                    }
                }
            }
        };

        // 4. 初始化规则引擎
        var ruleEngine = new DynamicJsonRuleEngine(ruleLogger, rules);

        // 5. 模拟设备上报的二进制数据
        // 字节0-3：36.5（float）、字节4：15（int8）
        byte[] rawData = new byte[] { 0x41, 0x48, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00 };

        // 6. 解析二进制→动态JSON
        string jsScript = @"
            function rawDataToProtocolData(rawData) {
                var uint8Array = new Uint8Array(rawData.length);
                for (var i = 0; i < rawData.length; i++) {
                    uint8Array[i] = rawData[i] & 0xff;
                }
                var dataView = new DataView(uint8Array.buffer, 0);
                var jsonMap = {
                    device: { id: ""dev_001"", status: ""normal_error"", online: true },
                    sensor: { temp: dataView.getFloat32(0), humidity: [dataView.getInt8(4), 50, 60] }
                };
                return jsonMap;
            }
        ";
        string dynamicJson = parser.RawDataToProtocolData(rawData, jsScript);
        Console.WriteLine($"解析后的动态JSON：{dynamicJson}\n");

        // 7. 规则引擎处理动态JSON
        var result = ruleEngine.Process(dynamicJson);

        // 8. 输出结果
        Console.WriteLine("\n=== 规则执行结果 ===");
        Console.WriteLine($"执行成功：{result.Success}");
        Console.WriteLine($"触发规则：{string.Join(", ", result.TriggeredRules)}");
        if (result.Errors.Count > 0)
        {
            Console.WriteLine("错误信息：");
            foreach (var err in result.Errors) Console.WriteLine($"- {err}");
        }
    }
}
```

------

### 步骤 5：执行结果输出

```plaintext
解析后的动态JSON：{"device":{"id":"dev_001","status":"normal_error","online":true},"sensor":{"temp":36.5,"humidity":[15,50,60]}}

=== 告警 === 高温告警：【温度超标告警】触发：$.sensor.temp = 36.5
=== 写入数据库 === Table[device_error_log]：$.device.status = normal_error
=== 转发Kafka === Topic[sensor_humidity_exception]：{"RuleId":"xxx","Field":"$.sensor.humidity[0]","Value":15,"Time":"2025-12-08T10:00:00"}

=== 规则执行结果 ===
执行成功：True
触发规则：温度超标告警, 设备状态异常, 湿度异常转发
```

------

### 核心亮点说明

1. **JSONPath 全兼容**：支持任意层级 / 数组的字段提取（如`$.sensor.humidity[0]`）；
2. **类型自适应**：无需预定义字段类型，自动识别 JSON 原生类型（float/int/string）；
3. **规则可配置**：用户只需配置 JSONPath、运算符、阈值，无需编码；
4. **动作可扩展**：通过`RuleAction`可新增任意动作（如 HTTP 回调、MQTT 下发）；
5. **容错性**：单个规则执行失败不影响其他规则，错误日志可追溯。

### 扩展优化建议

1. **规则热更新**：将规则存储在数据库 / 配置中心，定时拉取更新，无需重启引擎；
2. **表达式增强**：集成`DynamicExpresso`引擎，支持复杂表达式（如`(temp>35 && humidity<20) || status.contains("error")`）；
3. **性能优化**：缓存 JSONPath 解析结果，批量处理高并发 JSON 数据；
4. **可视化配置**：前端开发 JSONPath 编辑器，用户通过可视化选择字段，无需手写 JSONPath。