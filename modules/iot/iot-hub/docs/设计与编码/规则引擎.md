# 规则引擎

 上述基于物模型，自定义数据模版，对用户是友好的，但是这样的设计不够灵活， 像EMQX ，内置基于 SQL 的规则引擎，搭配 Schema Registry 和 Flow 设计器，可实时对物联网数据进行提取、过滤、转换等操作，帮我梳理下EMQX从定义规则引擎，数据转发的流程，挖掘中间设计可能隐藏的概念，然后使用C#、DotNet技术，帮设计一样的一套设计。 无需复杂编码即可编排消息处理流程在.Net 平台。



## MQX

### EMQX 规则引擎与数据处理流程解析

#### 核心概念与流程梳理

1. **核心组件**

   - **Schema Registry**：定义消息格式模板（如 JSON Schema/Protobuf），实现消息结构化解析的基准
   - **规则引擎**：基于 SQL 的规则定义（筛选条件 + 处理逻辑）
   - **动作（Action）**：规则匹配后的执行单元（转发到 Kafka / 数据库等）
   - **Flow 设计器**：可视化编排多步骤处理流程

2. **数据处理流程**

   ```plaintext
设备消息 → 接入层 → Schema解析（Schema Registry）→ 规则引擎匹配（SQL过滤）→ 动作执行（转发/存储）
   ```

   

3. **隐藏设计理念**

   - **松耦合架构**：规则、解析器、动作可独立扩展
   - **声明式编程**：用 SQL 描述处理逻辑，无需编码
   - **可观测性**：规则执行状态实时监控
   - **动态加载**：规则引擎运行中可更新规则与 schema

### .NET 平台平台实现方案设计

#### 1. 核心模块设计

```csharp
// 核心接口定义
public interface IMessageProcessor
{
    Task<ProcessResult> ProcessAsync(MessageContext context);
}

public interface ISchemaRegistry
{
    Task<Schema> GetSchemaAsync(string schemaId);
    Task<object> ParseMessageAsync(byte[] rawData, string schemaId);
}

public interface IRuleEngine
{
    Task<List<ActionExecutionPlan>> MatchRulesAsync(MessageContext context);
}

public interface IActionExecutor
{
    Task ExecuteAsync(ExecutionPlan plan, MessageContext context);
}
```

#### 2. 规则引擎核心实现

```csharp
/// <summary>
/// SQL式规则解析器（基于.NET DataTable.ComputeSQL支持）
/// </summary>
public class SqlRuleEngine : IRuleEngine
{
    private readonly IServiceProvider _serviceProvider;
    private readonly List<RuleDefinition> _rules;

    public SqlRuleEngine(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
        _rules = new List<RuleDefinition>();
    }

    public async Task<List<ExecutionPlan>> MatchRulesAsync(MessageContext context)
    {
        var matchedPlans = new List<ExecutionPlan>();
        
        // 将消息转换为DataTable以便SQL查询
        var dataTable = ConvertToDataTable(context.ParsedData);
        
        foreach (var rule in _rules)
        {
            if (await EvaluateRuleAsync(dataTable, rule.FilterSql))
            {
                var plan = new ExecutionPlan
                {
                    RuleId = rule.Id,
                    Actions = rule.Actions.Select(a => 
                        new ActionExecution
                        {
                            ActionType = a.Type,
                            Config = a.Config,
                            PayloadTemplate = a.PayloadTemplate
                        }).ToList()
                };
                matchedPlans.Add(plan);
            }
        }
        
        return matchedPlans;
    }

    private async Task<bool> EvaluateRuleAsync(DataTable dataTable, string filterSql)
    {
        try
        {
            // 使用DataTable.Select执行过滤SQL
            var rows = dataTable.Select(filterSql);
            return rows.Length > 0;
        }
        catch (Exception ex)
        {
            // 日志记录与错误处理
            return false;
        }
    }
}
```

#### 3. Schema Registry 实现

```csharp
public class JsonSchemaRegistry : ISchemaRegistry
{
    private readonly IDictionary<string, JsonSchema> _schemaCache;
    private readonly readonly IHttpClientFactory _httpClientFactory;

    public JsonSchemaRegistry(IHttpClientFactory httpClientFactory)
    {
        _schemaCache = new ConcurrentDictionary<string, JsonSchema>();
        _httpClientFactory = httpClientFactory;
    }

    public async Task<Schema> GetSchemaAsync(string schemaId)
    {
        if (_schemaCache.TryGetValue(schemaId, out var schema))
            return schema;

        // 从存储加载schema（支持远程加载）
        var client = _httpClientFactory.CreateClient();
        var response = await client.GetAsync($"https://schemas.example.com/{schemaId}");
        var schemaJson = await response.Content.ReadAsStringAsync();
        
        var jsonSchema = JsonSchema.Parse(schemaJson);
        _schemaCache[schemaId] = jsonSchema;
        return jsonSchema;
    }

    public async Task<object> ParseMessageAsync(byte[] rawData, string schemaId)
    {
        var schema = await GetSchemaAsync(schemaId);
        var json = Encoding.UTF8.GetString(rawData);
        var validated = JsonSerializer.Deserialize(json, schema.Type);
        
        // 执行schema验证
        var validationResult = schema.Validate(validated);
        if (!validationResult.IsValid)
            throw new SchemaValidationException(validationResult.Errors);
            
        return validated;
    }
}
```

#### 4. 可视化流程设计器后端支持



```csharp
/// <summary>
/// 流程定义DTO（供前端可视化设计器使用）
/// </summary>
public class FlowDefinition
{
    public string Id { get; set; }
    public string Name { get; set; }
    public List<NodeDefinition> Nodes { get; set; } = new();
    public List<ConnectionDefinition> Connections { get; set; } = new();
}

/// <summary>
/// 节点执行器
/// </summary>
public class FlowExecutor : IMessageProcessor
{
    private readonly IServiceProvider _serviceProvider;

    public async Task<ProcessResult> ProcessAsync(MessageContext context)
    {
        // 加载流程定义
        var flow = await _serviceProvider.GetRequiredService<IFlowRepository>()
            .GetByIdAsync(context.FlowId);

        // 执行节点链
        var currentNodes = flow.Nodes.Where(n => n.IsStartNode).ToList();
        while (currentNodes.Any())
        {
            var nextNodes = new List<NodeDefinition>();
            
            foreach (var node in currentNodes)
            {
                var processor = _serviceProvider.GetRequiredService<INodeProcessor>(node.Type);
                var result = await processor processorcessor.ProcessAsync(node, context);
                
                if (result.Success)
                {
                    nextNodes.AddRange(flow.GetNextNodes(node.Id));
                }
            }
            
            currentNodes = nextNodes;
        }
        
        return new ProcessResult { Success = true };
    }
}
```

#### 5. 动作执行器示例（转发到 Kafka）

```csharp
public class KafkaActionExecutor : IActionExecutor
{
    private readonly IProducer<Null, string> _producer;

    public KafkaActionExecutor(IConfiguration config)
    {
        var config = new ProducerConfig { BootstrapServers = "localhost:9092" };
        _producer = new ProducerBuilder<Null, string>(config).Build();
    }

    public async Task Task ExecuteAsync(ExecutionPlan plan, MessageContext context)
    {
        foreach (var action in plan.Actions)
        {
            if (action.ActionType != "kafka") continue;
            
            // 模板渲染（支持Liquid模板引擎）
            var template = new LiquidTemplate();
            var renderedPayload = template.Render(action.PayloadTemplate, context.ParsedData);
            
            // 发送到Kafka
            await _producer.ProduceAsync(
                action.Config["topic"], 
                new Message<Null, string> { Value = renderedPayload });
        }
        return Task.CompletedTask;
    }
}
```

### 关键技术选型

1. **规则解析**：使用`System.Data.DataTable`或`Sqlite`内存数据库支持 SQL 查询
2. **Schema 验证**：`Newtonsoft.Json.Schema`或`System.Text.Json`的验证功能
3. **模板引擎**：`Liquid.NET`用于支持灵活的 payload 转换
4. **可视化设计器**：前端可使用`jsPlumb`或`GoJS`实现流程图编辑
5. **动态加载**：使用`Microsoft.Extensions.DependencyInjection`的动态注册能力

### 优势与扩展点

1. **灵活性**：支持 SQL 式规则与可视化流程两种定义方式
2. **可扩展性**：通过接口抽象易于添加新的 Schema 解析器和动作类型
3. **性能优化**：规则规则匹配结果缓存、热点 Schema 缓存
4. **监控能力**：集成 OpenTelemetry 跟踪消息处理链路

该设计既保留了 EMQX 的灵活性，又利用.NET 生态的优势实现了低代码化的消息处理流程编排，适合在物联网场景中快速构建数据处理管道。



## 如何在规则引擎中定义消息格式模版等？

如何在规则引擎中实现规则的动态更新？

如何在规则引擎中实现规则的监控与告警？



### 一、如何在规则引擎中定义消息格式模板

消息格式模板设计目标：**标准化不同设备 / Topic 的消息结构描述**，为规则引擎提供解析依据，同时支持前端可视化配置和字段选取。结合你提供的`JavaScriptTslMessageParser`（基于 TSL 规范），可设计以下方案：

#### 1. 消息格式模板的数据结构定义

参考 TSL 规范和 EMQX 的 Schema Registry，定义结构化模板模型，存储在数据库中：

```csharp
/// <summary>
/// 消息格式模板（对应物模型/ Schema）
/// </summary>
public class MessageSchema
{
    public string Id { get; set; } // 唯一标识
    public string Name { get; set; } // 模板名称
    public string TopicPattern { get; set; } // 关联的Topic模式（支持通配符，如/device/{deviceId}/#）
    public List<SchemaField> Fields { get; set; } = new(); // 字段列表
    public string? ParseScript { get; set; } // 自定义解析脚本（复用JavaScriptTslMessageParser）
    public SchemaType Type { get; set; } = SchemaType.Json; // 格式类型：Json/Protobuf/Binary等
}

/// <summary>
/// 模板字段定义
/// </summary>
public class SchemaField
{
    public string FieldName { get; set; } // 字段名（支持嵌套路径，如data.temp）
    public string DataType { get; set; } // 数据类型（int8/string/float等，对应TSL类型）
    public string? Description { get; set; } // 描述
    public string? Unit { get; set; } // 单位
    public int? Offset { get; set; } // 二进制数据的偏移量（用于Binary类型）
    public int? Length { get; set; } // 二进制数据的长度（用于Binary类型）
    public bool IsRequired { get; set; } = false; // 是否必填字段
}

public enum SchemaType
{
    Json,       // JSON格式（自带结构）
    Protobuf,   // Protobuf（需关联.proto文件）
    Binary,     // 二进制（需解析脚本）
    Text        // 文本格式（如CSV）
}
```

#### 2. 模板与消息解析的联动

结合已有的`JavaScriptTslMessageParser`，实现模板驱动的消息解析：

- **对于 Binary 类型**：使用`MessageSchema.ParseScript`存储解析脚本（复用`RawDataToProtocolData`方法），将原始字节转换为结构化 JSON。
- **对于 JSON/Protobuf 类型**：通过`SchemaField`定义字段校验规则（如类型、必填项），解析后执行校验。

示例：解析流程

```csharp
public class SchemaBasedParser
{
    private readonly JavaScriptTslMessageParser _jsParser;
    private readonly ISchemaRepository _schemaRepo;

    public async Task<Dictionary<string, object>> ParseAsync(byte[] rawData, string topic)
    {
        // 1. 根据Topic匹配对应的消息模板
        var schema = await _schemaRepo.FindByTopicAsync(topic);
        if (schema == null) throw new Exception("未找到匹配的消息模板");

        // 2. 按模板类型解析
        string jsonData = schema.Type switch
        {
            SchemaType.Binary => _jsParser.RawDataToProtocolData(rawData, schema.ParseScript),
            SchemaType.Json => Encoding.UTF8.GetString(rawData), // 直接转JSON
            SchemaType.Protobuf => ParseProtobuf(rawData, schema), // 自定义Protobuf解析
            _ => throw new NotSupportedException()
        };

        // 3. 基于模板字段校验结构化数据
        var parsedData = JsonSerializer.Deserialize<Dictionary<string, object>>(jsonData);
        ValidateParsedData(parsedData, schema.Fields); // 校验字段存在性、类型等

        return parsedData;
    }

    private void ValidateParsedData(Dictionary<string, object> data, List<SchemaField> fields)
    {
        foreach (var field in fields.Where(f => f.IsRequired))
        {
            if (!data.ContainsKey(field.FieldName))
                throw new Exception($"缺失必填字段：{field.FieldName}");
            
            // 校验数据类型（简化示例）
            var value = data[field.FieldName];
            if (!IsTypeMatch(value, field.DataType))
                throw new Exception($"字段{field.FieldName}类型不匹配，预期{field.DataType}");
        }
    }
}
```

#### 3. 前端可视化配置

- 提供模板编辑界面，支持手动录入`SchemaField`或导入 JSON Schema/Protobuf 定义。
- 对于二进制模板，提供脚本编辑区（复用阿里云 TSL 解析脚本规范），与`JavaScriptTslMessageParser`兼容。

### 二、如何在规则引擎中实现规则的动态更新

规则动态更新的核心是**在不重启引擎的情况下，实时加载新规则、停用旧规则**，需解决 “规则存储”“内存同步”“并发安全” 三个问题。

#### 1. 规则的数据结构定义

```csharp
public class Rule
{
    public string Id { get; set; }
    public string Name { get; set; }
    public string SqlFilter { get; set; } // 规则条件（如：topic = '/device/123/temp' AND temp > 30）
    public List<RuleAction> Actions { get; set; } = new(); // 匹配后执行的动作（转发/存储等）
    public bool IsEnabled { get; set; } = true; // 是否启用
    public DateTime UpdatedAt { get; set; } // 最后更新时间
}

public class RuleAction
{
    public string Type { get; set; } // 动作类型：kafka/mqtt/http等
    public Dictionary<string, string> Config { get; set; } = new(); // 动作配置（如Kafka的Topic）
    public string? PayloadTemplate { get; set; } // 转发 payload 模板（如Liquid模板）
}
```

#### 2. 规则存储与加载策略

- **存储**：使用数据库（如 PostgreSQL）持久化规则，支持 CRUD 操作。

- **内存缓存**：规则引擎启动时加载所有启用的规则到内存（如`ConcurrentDictionary`），确保高吞吐查询。

- 动态更新触发

  ：

  - 主动触发：规则更新 API 调用后，即时同步内存缓存。
  - 被动触发：定时轮询数据库（如每 5 秒），对比`UpdatedAt`字段，更新有变化的规则。

#### 3. 并发安全的规则替换

使用读写锁（`ReaderWriterLockSlim`）确保规则更新时不影响正在执行的规则匹配：

```csharp
public class RuleEngine
{
    private readonly ConcurrentDictionary<string, Rule> _rules = new();
    private readonly ReaderWriterLockSlim _rwLock = new();
    private readonly IRuleRepository _ruleRepo;

    // 初始化：加载所有启用的规则
    public async Task InitializeAsync()
    {
        var rules = await _ruleRepo.GetAllEnabledAsync();
        foreach (var rule in rules)
            _rules[rule.Id] = rule;
    }

    // 动态更新规则（API调用时触发）
    public async Task UpdateRuleAsync(Rule updatedRule)
    {
        using var writeLock = _rwLock.EnterWriteLock(); // 独占锁，阻止读取
        
        // 1. 持久化到数据库
        await _ruleRepo.SaveAsync(updatedRule);
        
        // 2. 更新内存缓存
        if (updatedRule.IsEnabled)
            _rules[updatedRule.Id] = updatedRule;
        else
            _rules.TryRemove(updatedRule.Id, out _);
    }

    // 规则匹配（使用读锁，允许多线程并发读取）
    public List<Rule> MatchRules(Dictionary<string, object> parsedData, string topic)
    {
        using var readLock = _rwLock.EnterReadLock(); // 共享锁，不阻塞其他读取
        
        var matched = new List<Rule>();
        foreach (var rule in _rules.Values)
        {
            if (IsRuleMatch(rule, parsedData, topic)) // 执行SQL过滤或表达式计算
                matched.Add(rule);
        }
        return matched;
    }
}
```

#### 4. 规则解析器的动态性

- 对于 SQL 过滤条件（`SqlFilter`），使用轻量级 SQL 解析器（如`SqlKata`）或表达式引擎（如`DynamicExpresso`），支持动态编译表达式，避免硬编码逻辑。
- 示例：使用`DynamicExpresso`解析过滤条件：

```csharp
private bool IsRuleMatch(Rule rule, Dictionary<string, object> data, string topic)
{
    var interpreter = new Interpreter();
    // 注入上下文变量（消息字段+topic）
    interpreter.SetVariable("topic", topic);
    foreach (var (key, value) in data)
        interpreter.SetVariable(key, value);
    
    // 执行过滤表达式（如："topic.Contains('temp') && temp > 30"）
    return interpreter.Evaluate<bool>(rule.SqlFilter);
}
```

### 三、如何在规则引擎中实现规则的监控与告警

监控与告警的目标是**跟踪规则执行状态、及时发现异常**，需覆盖 “指标采集”“异常检测”“告警触发” 三个环节。

#### 1. 规则执行指标采集

定义核心指标，通过计数器 / 计时器记录：

```csharp
public class RuleMetrics
{
    // 规则ID
    public string RuleId { get; set; }
    // 总匹配次数
    public long MatchCount { get; set; }
    // 总执行成功次数
    public long SuccessCount { get; set; }
    // 总执行失败次数
    public long FailureCount { get; set; }
    // 最近一次失败时间
    public DateTime? LastFailureTime { get; set; }
    // 最近一次失败原因
    public string? LastFailureReason { get; set; }
    // 平均执行耗时（毫秒）
    public double AvgExecutionTimeMs { get; set; }
}
```

在规则执行流程中埋点采集：

```csharp
public async Task ExecuteRuleActionsAsync(Rule rule, Dictionary<string, object> data)
{
    var stopwatch = Stopwatch.StartNew();
    try
    {
        foreach (var action in rule.Actions)
        {
            await _actionExecutor.ExecuteAsync(action, data); // 执行动作（转发等）
        }
        
        // 更新成功指标
        _metricsService.IncrementSuccess(rule.Id, stopwatch.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        // 更新失败指标
        _metricsService.IncrementFailure(rule.Id, ex.Message, stopwatch.ElapsedMilliseconds);
        throw;
    }
}
```

#### 2. 告警规则定义

允许用户配置告警触发条件（与业务规则分离）：

```csharp
public class AlertRule
{
    public string Id { get; set; }
    public string RuleId { get; set; } // 关联的业务规则ID（可为空，表示全局告警）
    public AlertCondition Condition { get; set; } // 触发条件
    public int Threshold { get; set; } // 阈值（如失败次数>5）
    public int WindowSeconds { get; set; } // 统计窗口（如5分钟内）
    public List<AlertNotification> Notifications { get; set; } = new(); // 通知方式
}

public enum AlertCondition
{
    FailureCountExceeded, // 失败次数超过阈值
    ExecutionTimeExceeded, // 执行耗时超过阈值
    NoMatchesForDuration, // 长时间无匹配
}

public class AlertNotification
{
    public string Type { get; set; } // 通知方式：email/sms/webhook
    public string Target { get; set; } // 目标（如邮箱地址、Webhook URL）
}
```

#### 3. 告警检测与触发

- **定时检测**：使用定时任务（如 Hangfire），周期性（如每 10 秒）检查指标是否满足告警条件。
- **示例逻辑**：

```csharp
public class AlertChecker
{
    private readonly IRuleMetricsRepository _metricsRepo;
    private readonly IAlertRuleRepository _alertRepo;
    private readonly INotificationService _notificationService;

    public async Task CheckAlertsAsync()
    {
        var alertRules = await _alertRepo.GetAllEnabledAsync();
        foreach (var alertRule in alertRules)
        {
            // 1. 查询时间窗口内的指标
            var metrics = await _metricsRepo.GetMetricsInWindowAsync(
                alertRule.RuleId, 
                TimeSpan.FromSeconds(alertRule.WindowSeconds)
            );

            // 2. 判断是否触发告警
            bool isTriggered = alertRule.Condition switch
            {
                AlertCondition.FailureCountExceeded => 
                    metrics.FailureCount > alertRule.Threshold,
                AlertCondition.ExecutionTimeExceeded => 
                    metrics.AvgExecutionTimeMs > alertRule.Threshold,
                _ => false
            };

            // 3. 触发通知（避免重复告警，可记录最近告警时间）
            if (isTriggered && !IsRecentAlerted(alertRule.Id))
            {
                foreach (var notification in alertRule.Notifications)
                {
                    await _notificationService.SendAsync(
                        notification.Type,
                        notification.Target,
                        $"规则{alertRule.RuleId}触发告警：{alertRule.Condition}"
                    );
                }
            }
        }
    }
}
```

#### 4. 可视化监控

- 集成时序数据库（如 InfluxDB/Prometheus）存储指标，通过 Grafana 展示规则执行趋势。
- 提供规则详情页，显示实时指标（匹配次数、成功率、耗时等）和最近异常日志。

### 总结

1. **消息格式模板**：通过`MessageSchema`标准化结构，结合`JavaScriptTslMessageParser`实现多格式解析，支持前端可视化配置。
2. **规则动态更新**：基于数据库 + 内存缓存，使用读写锁保证并发安全，通过表达式引擎动态解析规则条件。
3. **监控与告警**：采集指标采集 + 定时检测 + 多渠道通知，覆盖规则业务规则与告警规则分离，提升灵活性。

该方案可与你现有的`JavaScriptTslMessageParser`无缝集成，同时保留 EMQX 式的灵活性和低代码特性。



## 如何在规则引擎中实现规则的版本管理？

在规则引擎中实现规则的版本管理，核心目标是**追踪规则变更历史、支持版本回滚、控制版本发布 / 灰度 / 下线流程**，同时保证规则执行的原子性和一致性。以下是基于.NET 技术栈的完整设计方案，包含核心概念、数据结构、核心流程和实现细节：

### 一、核心设计理念

1. **版本化核心原则**

   - 规则的每次修改生成新版本，旧版本保留（支持追溯 / 回滚）；
   - 同一规则 ID 下仅一个版本为「生效版本」，其余为「历史版本」；
   - 支持版本的发布 / 灰度 / 下线状态流转，避免直接删除规则；
   - 版本变更需记录操作人、操作时间、变更原因（审计追溯）。

2. **关键概念定义**

   | 概念       | 说明                                                         |
   | ---------- | ------------------------------------------------------------ |
   | 规则 ID    | 规则的唯一标识（跨版本不变），如`rule_device_temp_alert`     |
   | 版本号     | 语义化版本（如 1.0.0）或递增数字（如 v1/v2），标记规则的迭代版本 |
   | 版本状态   | 草稿 / 待发布 / 已发布（生效）/ 灰度中 / 已下线 / 已废弃     |
   | 变更日志   | 记录版本的修改内容、操作人、操作时间、变更原因               |
   | 生效规则集 | 内存中仅加载「已发布 / 灰度中」的版本，保证规则引擎执行效率  |

### 二、核心数据结构设计

基于.NET 实体类定义版本化规则的存储模型（可直接映射到数据库）：

```csharp
/// <summary>
/// 规则主表（跨版本的基础信息）
/// </summary>
public class Rule
{
    public string Id { get; set; } = Guid.NewGuid().ToString(); // 规则唯一标识（不变）
    public string Name { get; set; } // 规则名称（可修改）
    public string Description { get; set; } // 规则描述
    public string TopicPattern { get; set; } // 关联的Topic模式（如/device/{deviceId}/#）
    public string CurrentVersion { get; set; } // 当前生效版本号
    public RuleStatus Status { get; set; } = RuleStatus.Draft; // 规则整体状态
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public string CreatedBy { get; set; } // 创建人
}

/// <summary>
/// 规则版本表（每次修改生成新记录）
/// </summary>
public class RuleVersion
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string RuleId { get; set; } // 关联规则主表ID
    public string Version { get; set; } // 版本号（如1.0.0、v2）
    public string SqlFilter { get; set; } // 规则过滤条件（SQL/表达式）
    public List<RuleAction> Actions { get; set; } = new(); // 规则动作列表
    public RuleVersionStatus VersionStatus { get; set; } = RuleVersionStatus.Draft; // 版本状态
    public string ChangeLog { get; set; } // 变更日志（如"修改温度阈值为35℃"）
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public string UpdatedBy { get; set; } // 操作人
    public bool IsCurrent { get; set; } = false; // 是否为当前生效版本
}

/// <summary>
/// 规则动作（版本内的执行动作）
/// </summary>
public class RuleAction
{
    public string Type { get; set; } // 动作类型：kafka/mqtt/http等
    public Dictionary<string, string> Config { get; set; } = new(); // 动作配置
    public string PayloadTemplate { get; set; } // 转发模板
}

/// <summary>
/// 规则整体状态（跨版本）
/// </summary>
public enum RuleStatus
{
    Draft = 0,      // 草稿（无生效版本）
    Published = 1,  // 已发布（有生效版本）
    Gray = 2,       // 灰度中
    Offline = 3     // 已下线（无生效版本）
}

/// <summary>
/// 规则版本状态
/// </summary>
public enum RuleVersionStatus
{
    Draft = 0,      // 草稿（未发布）
    Pending = 1,    // 待发布
    Published = 2,  // 已发布（生效）
    Gray = 3,       // 灰度中
    Offline = 4,    // 已下线
    Abandoned = 5   // 已废弃（草稿未发布，手动标记废弃）
}
```

### 三、核心流程实现

#### 1. 版本创建与修改

- **新建规则**：先创建`Rule`主记录，再生成第一个`RuleVersion`（版本号 1.0.0，状态 Draft）；

- **修改规则**：基于当前版本复制生成新版本（版本号递增，如 1.0.1），修改内容仅作用于新版本，旧版本保留；

- 版本号生成策略

  ：支持两种方式（可配置）：

  - 语义化版本：主版本。次版本。修订版（如 1.0.0 → 1.0.1 → 1.1.0）；
  - 递增数字版本：v1 → v2 → v3（简单易管理）。

```csharp
public class RuleVersionService
{
    private readonly IRuleRepository _ruleRepo;
    private readonly IRuleVersionRepository _versionRepo;

    /// <summary>
    /// 基于当前版本创建新版本（修改规则时调用）
    /// </summary>
    public async Task<RuleVersion> CreateNewVersionAsync(string ruleId, string operatorId, string changeLog)
    {
        // 1. 获取规则主信息
        var rule = await _ruleRepo.GetByIdAsync(ruleId) ?? throw new Exception("规则不存在");
        
        // 2. 获取当前生效版本（无则取最新草稿）
        var currentVersion = await _versionRepo.GetCurrentVersionAsync(ruleId) 
                             ?? await _versionRepo.GetLatestVersionAsync(ruleId);
        
        // 3. 生成新版本号（语义化示例）
        var newVersion = GenerateNewVersionNumber(currentVersion?.Version ?? "1.0.0");
        
        // 4. 复制当前版本内容，创建新版本（草稿状态）
        var newRuleVersion = new RuleVersion
        {
            RuleId = ruleId,
            Version = newVersion,
            SqlFilter = currentVersion?.SqlFilter ?? "",
            Actions = currentVersion?.Actions?.Select(a => new RuleAction
            {
                Type = a.Type,
                Config = new Dictionary<string, string>(a.Config),
                PayloadTemplate = a.PayloadTemplate
            }).ToList() ?? new List<RuleAction>(),
            VersionStatus = RuleVersionStatus.Draft,
            ChangeLog = changeLog,
            UpdatedBy = operatorId,
            IsCurrent = false
        };
        
        await _versionRepo.AddAsync(newRuleVersion);
        return newRuleVersion;
    }

    /// <summary>
    /// 生成语义化新版本号（修订版+1）
    /// </summary>
    private string GenerateNewVersionNumber(string currentVersion)
    {
        var parts = currentVersion.Split('.');
        if (parts.Length != 3) return $"{currentVersion}.1"; // 兼容非标准版本号
        int patch = int.Parse(parts[2]) + 1;
        return $"{parts[0]}.{parts[1]}.{patch}";
    }
}
```

#### 2. 版本发布与生效

版本发布需保证**原子性**（旧版本下线、新版本上线无间隙），同时更新内存中的规则缓存：

```csharp
public class RulePublishService
{
    private readonly IRuleRepository _ruleRepo;
    private readonly IRuleVersionRepository _versionRepo;
    private readonly RuleEngine _ruleEngine; // 规则引擎实例
    private readonly ReaderWriterLockSlim _rwLock = new(); // 并发锁

    /// <summary>
    /// 发布指定版本（设为生效版本）
    /// </summary>
    public async Task PublishVersionAsync(string ruleId, string version, string operatorId)
    {
        using var writeLock = _rwLock.EnterWriteLock(); // 独占锁，保证原子性
        
        // 1. 校验版本状态
        var targetVersion = await _versionRepo.GetByRuleIdAndVersionAsync(ruleId, version) 
                            ?? throw new Exception("版本不存在");
        if (targetVersion.VersionStatus != RuleVersionStatus.Draft && 
            targetVersion.VersionStatus != RuleVersionStatus.Pending)
            throw new Exception("仅草稿/待发布版本可发布");

        // 2. 下线旧生效版本
        var oldCurrentVersion = await _versionRepo.GetCurrentVersionAsync(ruleId);
        if (oldCurrentVersion != null)
        {
            oldCurrentVersion.IsCurrent = false;
            oldCurrentVersion.VersionStatus = RuleVersionStatus.Offline;
            await _versionRepo.UpdateAsync(oldCurrentVersion);
        }

        // 3. 上线新版本
        targetVersion.IsCurrent = true;
        targetVersion.VersionStatus = RuleVersionStatus.Published;
        await _versionRepo.UpdateAsync(targetVersion);

        // 4. 更新规则主表的当前版本
        var rule = await _ruleRepo.GetByIdAsync(ruleId);
        rule.CurrentVersion = version;
        rule.Status = RuleStatus.Published;
        await _ruleRepo.UpdateAsync(rule);

        // 5. 刷新规则引擎内存缓存
        await _ruleEngine.RefreshRuleCacheAsync(ruleId);
    }
}
```

#### 3. 版本回滚

回滚本质是将历史版本重新设为生效版本，流程与发布一致：

```csharp
/// <summary>
/// 回滚到指定历史版本
/// </summary>
public async Task RollbackToVersionAsync(string ruleId, string targetVersion, string operatorId, string changeLog)
{
    // 1. 校验目标版本是否为历史版本（已发布/已下线）
    var target = await _versionRepo.GetByRuleIdAndVersionAsync(ruleId, targetVersion) 
                 ?? throw new Exception("回滚版本不存在");
    if (target.VersionStatus == RuleVersionStatus.Draft || target.VersionStatus == RuleVersionStatus.Abandoned)
        throw new Exception("仅已发布/已下线版本可回滚");

    // 2. 基于历史版本创建新版本（保留回滚痕迹）
    var newVersion = await _ruleVersionService.CreateNewVersionAsync(ruleId, operatorId, 
        $"回滚到版本{targetVersion}：{changeLog}");
    
    // 3. 覆盖新版本内容为目标版本内容
    newVersion.SqlFilter = target.SqlFilter;
    newVersion.Actions = target.Actions;
    await _versionRepo.UpdateAsync(newVersion);

    // 4. 发布新版本（原子替换当前版本）
    await PublishVersionAsync(ruleId, newVersion.Version, operatorId);
}
```

#### 4. 版本灰度发布（可选）

针对重要规则，支持灰度发布（仅对部分设备 / Topic 生效）：

```csharp
/// <summary>
/// 灰度发布版本（仅匹配指定设备/Topic）
/// </summary>
public async Task GrayPublishVersionAsync(string ruleId, string version, List<string> grayDeviceIds, string operatorId)
{
    // 1. 标记版本为灰度中
    var targetVersion = await _versionRepo.GetByRuleIdAndVersionAsync(ruleId, version);
    targetVersion.VersionStatus = RuleVersionStatus.Gray;
    targetVersion.IsCurrent = true; // 灰度版本也标记为当前版本
    await _versionRepo.UpdateAsync(targetVersion);

    // 2. 更新规则引擎灰度配置（内存中记录灰度设备列表）
    await _ruleEngine.SetGrayConfigAsync(ruleId, version, grayDeviceIds);

    // 3. 更新规则主表状态
    var rule = await _ruleRepo.GetByIdAsync(ruleId);
    rule.Status = RuleStatus.Gray;
    await _ruleRepo.UpdateAsync(rule);
}
```

### 四、规则引擎的版本适配

规则引擎需感知版本变化，保证执行的是当前生效版本：

```csharp
public class RuleEngine
{
    // 内存缓存：规则ID → 当前生效版本（含灰度配置）
    private readonly ConcurrentDictionary<string, RuleVersionCache> _ruleCache = new();
    private readonly IRuleVersionRepository _versionRepo;

    /// <summary>
    /// 规则缓存模型
    /// </summary>
    private class RuleVersionCache
    {
        public RuleVersion Version { get; set; }
        public List<string> GrayDeviceIds { get; set; } = new(); // 灰度设备列表
    }

    /// <summary>
    /// 刷新规则缓存（版本发布/回滚时调用）
    /// </summary>
    public async Task RefreshRuleCacheAsync(string ruleId)
    {
        var currentVersion = await _versionRepo.GetCurrentVersionAsync(ruleId);
        if (currentVersion == null)
        {
            _ruleCache.TryRemove(ruleId, out _);
            return;
        }

        // 加载灰度配置（如有）
        var grayConfig = await _grayConfigRepo.GetByRuleIdAsync(ruleId);
        
        _ruleCache[ruleId] = new RuleVersionCache
        {
            Version = currentVersion,
            GrayDeviceIds = grayConfig?.DeviceIds ?? new List<string>()
        };
    }

    /// <summary>
    /// 规则匹配（适配版本和灰度）
    /// </summary>
    public List<RuleVersion> MatchRulesAsync(MessageContext context)
    {
        var matched = new List<RuleVersion>();
        foreach (var (ruleId, cache) in _ruleCache)
        {
            var version = cache.Version;
            
            // 灰度判断：仅灰度设备匹配灰度版本
            if (version.VersionStatus == RuleVersionStatus.Gray && 
                !cache.GrayDeviceIds.Contains(context.DeviceId))
                continue;

            // 执行规则匹配逻辑
            if (IsRuleMatch(version, context))
                matched.Add(version);
        }
        return matched;
    }
}
```

### 五、版本管理的可视化与审计

1. **版本列表展示**：前端展示规则的所有版本，标注当前生效版本、版本状态、变更日志；
2. **版本对比**：支持对比两个版本的差异（SQL 过滤条件、动作配置等）；
3. **审计日志**：记录所有版本操作（创建 / 发布 / 回滚 / 下线），包含操作人、时间、IP、变更内容；
4. **版本下线 / 废弃**：支持将生效版本下线（规则整体失效），或废弃草稿版本（清理无效版本）。

### 六、关键优化点

1. 性能优化：
   - 内存缓存仅加载生效 / 灰度版本，历史版本不加载；
   - 版本数据分页查询，避免一次性加载大量历史版本；
2. 并发安全：
   - 所有版本变更操作加读写锁，保证原子性；
   - 规则引擎匹配时使用读锁，不阻塞版本发布；
3. 数据清理：
   - 定期归档 / 删除已废弃的草稿版本（保留审计记录）；
   - 历史版本保留可配置（如保留最近 10 个版本）。

### 总结

该方案通过「规则主表 + 版本子表」的分离设计，实现了规则的全生命周期版本管理，核心优势：

- **可追溯**：所有修改记录可查，支持审计和合规要求；
- **可回滚**：任意版本可回滚，避免规则修改导致的线上故障；
- **可灰度**：支持灰度发布，降低规则变更风险；
- **低侵入**：规则引擎仅需适配版本缓存，核心匹配逻辑无需修改。

该设计可无缝集成到你现有的规则引擎中，结合之前的消息格式模板、动态更新、监控告警能力，形成完整的物联网规则引擎解决方案。



如何在规则引擎中实现规则的灰度发布？

如何在规则引擎中实现规则的回滚？

如何在规则引擎中实现的发布流转？



##  如何在规则引擎中实现规则的灰度发布？ 

### 一、如何在规则引擎中实现规则的灰度发布

灰度发布（又称金丝雀发布）的核心目标是：**让新规则在部分流量 / 设备中先行生效，验证无误后再全量发布**，降低直接全量更新的风险。结合规则引擎的特性，可设计以下方案：

#### 1. 核心设计：规则版本与灰度策略

在原有`Rule`模型基础上扩展版本和灰度属性：

csharp



运行









```csharp
public class Rule
{
    public string Id { get; set; } // 规则唯一标识（跨版本不变）
    public int Version { get; set; } // 版本号（如1,2,3...）
    public string Name { get; set; }
    public string SqlFilter { get; set; }
    public List<RuleAction> Actions { get; set; } = new();
    
    // 灰度发布相关字段
    public RuleStatus Status { get; set; } // 状态：Draft/Released/Gray/Obsolete
    public GrayReleasePolicy? GrayPolicy { get; set; } // 灰度策略（仅Status=Gray时生效）
}

// 灰度策略
public class GrayReleasePolicy
{
    public GrayType Type { get; set; } // 灰度类型：按设备ID/Topic前缀/比例
    public List<string>? Targets { get; set; } // 目标列表（如设备ID列表）
    public int? Percentage { get; set; } // 流量比例（0-100，仅Type=Percentage时生效）
    public DateTime? StartTime { get; set; } // 灰度开始时间
    public DateTime? EndTime { get; set; } // 灰度结束时间（自动全量）
}

public enum RuleStatus { Draft, Released, Gray, Obsolete }
public enum GrayType { DeviceId, TopicPrefix, Percentage }
```

#### 2. 灰度流量路由逻辑

在规则匹配阶段，根据灰度策略筛选符合条件的消息，仅对这些消息应用新版本规则：

csharp



运行









```csharp
public class GrayReleaseRouter
{
    private readonly IRuleRepository _ruleRepo;

    // 获取当前生效的规则（优先灰度规则优先匹配）
    public async Task<List<Rule>> GetEffectiveRulesAsync(string topic, string deviceId, Dictionary<string, object> data)
    {
        // 1. 查询所有相关规则（同一Id的最新版本+灰度版本）
        var candidateRules = await _ruleRepo.GetActiveRulesAsync(topic);
        
        var effectiveRules = new List<Rule>();
        foreach (var ruleGroup in candidateRules.GroupBy(r => r.Id))
        {
            // 2. 检查是否有灰度版本
            var grayRule = ruleGroup.FirstOrDefault(r => r.Status == RuleStatus.Gray).FirstOrDefault();
            if (grayRule != null && IsMatchGrayPolicy(grayRule.GrayPolicy, topic, deviceId))
            {
                effectiveRules.Add(grayRule); // 命中灰度规则，使用灰度版本
                continue;
            }
            
            // 3. 无灰度或未命中，使用已发布的最新版本
            var releasedRule = ruleGroup
                .Where(r => r.Status == RuleStatus.Released)
                .OrderByDescending(r => r.Version)
                .FirstOrDefault();
            if (releasedRule != null)
                effectiveRules.Add(releasedRule);
        }
        
        return effectiveRules;
    }

    // 判断消息是否命中灰度策略
    private bool IsMatchGrayPolicy(GrayReleasePolicy? policy, string topic, string deviceId)
    {
        if (policy == null || policy.StartTime > DateTime.Now || policy.EndTime < DateTime.Now)
            return false;

        return policy.Type switch
        {
            GrayType.DeviceId => policy.Targets?.Contains(deviceId) ?? false,
            GrayType.TopicPrefix => policy.Targets?.Any(topic.StartsWith) ?? false,
            GrayType.Percentage => 
                policy.Percentage > 0 && 
                GetHash(deviceId) % 100 < policy.Percentage, // 基于设备ID哈希的比例分配
            _ => false
        };
    }

    // 简单哈希函数（确保同一设备ID始终映射到同一值）
    private int GetHash(string deviceId)
    {
        return Math.Abs(deviceId.GetHashCode() % 100);
    }
}
```

#### 3. 灰度发布流程

1. **创建新版本规则**：基于现有规则复制生成新版本（Version+1），状态设为`Draft`。
2. **配置灰度策略**：设置灰度类型（如 10% 设备、特定设备 ID 列表）。
3. **启动灰度**：将新版本状态改为`Gray`，此时规则开始对命中的流量生效。
4. **监控灰度指标**：通过规则监控系统观察灰度规则的执行成功率、耗时等指标。
5. **全量发布**：确认无异常后，将灰度版本状态改为`Released`，并将旧版本标记为`Obsolete`。

### 二、如何在规则引擎中实现规则的回滚

规则回滚的核心是**快速将规则恢复到历史稳定版本**，需依赖版本管理和状态切换机制。

#### 1. 版本管理基础

- 所有规则修改均生成新版本（递增`Version`），不直接修改旧版本。
- 历史版本保留`Obsolete`状态，不参与删除，用于回滚备选。

#### 2. 回滚触发机制

csharp



运行









```csharp
public class RuleRollbackService
{
    private readonly IRuleRepository _ruleRepo;
    private readonly RuleEngine _ruleEngine; // 规则引擎实例

    public async Task RollbackAsync(string ruleId, int targetVersion)
    {
        // 1. 校验证目标版本存在
        var targetRule = await _ruleRepo.GetByIdAndVersionAsync(ruleId, targetVersion);
        if (targetRule == null)
            throw new ArgumentException("目标版本不存在");

        // 2. 获取当前生效版本（最新Released/Gray）
        var currentRules = await _ruleRepo.GetByRuleIdAsync(ruleId);
        var currentActive = currentRules
            .Where(r => r.Status is RuleStatus.Released or RuleStatus.Gray)
            .OrderByDescending(r => r.Version)
            .FirstOrDefault();

        // 3. 停用当前版本
        if (currentActive != null)
        {
            currentActive.Status = RuleStatus.Obsolete;
            await _ruleRepo.UpdateAsync(currentActive);
        }

        // 4. 激活目标版本
        targetRule.Status = RuleStatus.Released;
        await _ruleRepoRepo.UpdateAsync(targetRule);

        // 5. 通知规则引擎刷新内存缓存
        await _ruleEngine.RefreshRulesAsync();
    }
}
```

#### 3. 回滚保障机制

- **原子性操作**：使用数据库事务确保版本状态切换的原子性（旧版本停用与目标版本激活要么同时成功，要么同时失败）。
- **灰度回滚支持**：若当前处于灰度发布中，回滚时可直接将灰度版本标记为`Obsolete`，并激活上一个稳定版本。
- **操作日志**：记录回滚操作（操作人员、时间、目标版本），用于审计和问题追溯。

### 三、如何在规则引擎中实现规则的发布流转

发布流转指**规则从创建到废弃的全生命周期管理流程**，通过状态机控制流转，确保规则变更可追溯、可审核。

#### 1. 规则生命周期状态机

定义规则的状态流转关系（状态机）：

plaintext











```plaintext
Draft（草稿） → PendingReview（待审核） → Released（已发布）
                   ↑                        ↓
               Rejected（已驳回）    →    Obsolete（已废弃）
                                          ↑
                        Gray（灰度中） → ┘
```

对应状态枚举：

csharp



运行









```csharp
public enum RuleStatus
{
    Draft,          // 草稿：编辑中，不生效
    PendingReview,  // 待审核：编辑完成，等待审核
    Rejected,       // 已驳回：审核不通过，需修改
    Released,       // 已发布：全量生效
    Gray,           // 灰度中：部分流量生效
    Obsolete        // 已废弃：被新版本替代
}
```

#### 2. 状态流转控制

通过流转服务实现状态变更的校验和触发：

csharp



运行









```csharp
public class RuleFlowService
{
    private readonly IRuleRepository _ruleRepo;
    private readonly IRuleAuditLogRepository _auditLogRepo;

    // 状态流转方法
    public async Task ChangeStatusAsync(string ruleId, int version, RuleStatus targetStatus, string operatorId, string comment)
    {
        var rule = await _ruleRepo.GetByIdAndVersionAsync(ruleId, version);
        if (rule == null)
            throw new ArgumentException("规则不存在");

        // 校验证状态流转合法性
        if (!IsValidTransition(rule.Status, targetStatus))
            throw new InvalidOperationException($"不允许从{rule.Status}流转到{targetStatus}");

        // 审核环节特殊处理（如Pending审核通过/驳回）
        if (targetStatus == RuleStatus.Released || targetStatus == RuleStatus.Rejected)
        {
            if (rule.Status != RuleStatus.PendingReview)
                throw new InvalidOperationException("仅待审核状态可执行审核操作");
            
            // 记录审核结果
            await _auditLogRepo.AddAsync(new RuleAuditLog
            {
                RuleId = ruleId,
                Version = version,
                OperatorId = operatorId,
                Action = targetStatus == RuleStatus.Released ? "Approved" : "Rejected",
                Comment = comment,
                OperatedAt = DateTime.Now
            });
        }

        // 更新状态
        rule.Status = targetStatus;
        await _ruleRepo.UpdateAsync(rule);

        // 若发布成功，同步旧版本标记为废弃
        if (targetStatus == RuleStatus.Released)
        {
            var oldVersions = await _ruleRepo.GetOlderReleasedVersionsAsync(ruleId, version);
            foreach (var old in oldVersions)
            {
                old.Status = RuleStatus.Obsolete;
                await _ruleRepoRepo.UpdateAsync(old);
            }
        }

        return Task.CompletedTask;
    }

    // 校验状态流转是否合法
    private bool IsValidTransition(RuleStatus current, RuleStatus target)
    {
        var validTransitions = new Dictionary<RuleStatus, List<RuleStatus>>
        {
            { RuleStatus.Draft, new() { RuleStatus.PendingReview, RuleStatus.Obsolete } },
            { RuleStatus.PendingReview, new() { RuleStatus.Released, RuleStatus.Rejected } },
            { RuleStatus.Rejected, new() { RuleStatus.PendingReview, RuleStatus.Obsolete } },
            { RuleStatus.Released, new() { RuleStatus.Gray, RuleStatus.Obsolete } },
            { RuleStatus.Gray, new() { RuleStatus.Released, RuleStatus.Obsolete } },
            { RuleStatus.Obsolete, new() { } } // 废弃废弃状态不可流转
        };

        return validTransitions[current].Contains(target);
    }
}
```

#### 3. 流转可视化与权限控制

- **前端流程界面**：展示规则当前状态，提供合法的状态切换按钮（如草稿状态仅显示 “提交审核”）。
- **权限控制**：不同角色拥有不同操作权限（如开发人员可创建草稿，审核人员可通过 / 驳回，管理员可强制废弃）。
- **流转日志**：记录每一次状态变更（操作人、时间、备注），支持回溯规则变更历史。

### 总结

1. **灰度发布**：通过版本管理 + 灰度策略（设备 / 比例 / Topic）实现规则在部分流量生效，依赖监控指标后全量发布。
2. **规则回滚**：基于历史版本库，通过状态切换换快速激活旧版本，确保原子性操作。
3. **发布流转**：定义状态机控制规则从草稿→审核→发布→废弃的全流程，结合权限核日志和权限控制确保合规性。

以上方案可与现有`JavaScriptTslMessageParser`无缝集成，规则的灰度 / 回滚 / 流转转逻辑不

 影响消息解析核心逻辑，仅在规则匹配和版本管理层面扩展。 

