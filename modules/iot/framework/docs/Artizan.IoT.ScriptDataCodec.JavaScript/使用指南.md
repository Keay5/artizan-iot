## 一、核心类使用示例与场景分析

### 1. JavaScriptDataCodec 基础使用示例（单线程 / 低并发场景）

#### 适用场景

- 低并发的设备数据解析（如单设备调试、离线数据解析）；
- 脚本逻辑调试、单次数据转换；
- 不需要复用编解码器实例的场景。

#### 代码示例

```C#
using Artizan.IoT.DataCodec.Core.Models;
using Artizan.IoT.DataCodec.Core.Utils.Logging;
using Artizan.IoT.DataCodec.JavaScript.Engines;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

// 1. 初始化日志（生产环境替换为实际ILogger）
CodecLogger.Initialize(NullLogger.Instance);

// 2. 定义测试JS脚本（自定义温湿度解码+LED编码）
var testScript = @"
    // 解码：原始byte数组 → 温湿度JSON
    function decodeTempHumidity(rawData) {
        var temp = (rawData[0] << 8 | rawData[1]) / 10;
        var humi = (rawData[2] << 8 | rawData[3]) / 10;
        return { method: 'property.post', params: { Temp: temp, Humi: humi } };
    }

    // 编码：JSON指令 → 设备控制byte数组
    function encodeLedControl(protocolData) {
        var data = JSON.parse(protocolData);
        return [0xAA, data.ledOn ? 0x01 : 0x00, 0x55];
    }
";

// 3. 创建编解码器实例（单次使用）
using var jsCodec = new JavaScriptDataCodec(testScript);

// 4. 尝试占用实例（线程安全校验）
if (jsCodec.TryAcquire())
{
    try
    {
        // ========== 场景1：解码原始设备数据 ==========
        var decodeContext = new ScriptExecutionContext
        {
            RawData = new byte[] { 0x01, 0x2C, 0x02, 0x58 }, // 温度30.0℃，湿度60.0%
            MethodName = "decodeTempHumidity",
            ProductKey = "sensor_001",
            DeviceName = "temp_humi_sensor_01"
        };
        var decodeResult = await jsCodec.DecodeAsync(decodeContext);
        if (decodeResult.Success)
        {
            Console.WriteLine($"解码结果：{decodeResult.OutputProtocolData}");
            // 输出：{"method":"property.post","params":{"Temp":30.0,"Humi":60.0}}
        }

        // ========== 场景2：编码设备控制指令 ==========
        var encodeContext = new ScriptExecutionContext
        {
            ProtocolData = "{\"ledOn\": true}",
            MethodName = "encodeLedControl",
            ProductKey = "sensor_001",
            DeviceName = "temp_humi_sensor_01"
        };
        var encodeResult = await jsCodec.EncodeAsync(encodeContext);
        if (encodeResult.Success)
        {
            Console.WriteLine($"编码结果（16进制）：{BitConverter.ToString(encodeResult.OutputRawData)}");
            // 输出：AA-01-55
        }
    }
    finally
    {
        // 释放实例（必须执行，否则下次无法占用）
        jsCodec.Release();
    }
}
```

### 2. JavaScriptCodecPoolManager 使用示例（高并发场景）

#### 适用场景

- 高并发的 IoT 设备数据解析（如每秒上千台设备上报数据）；
- 需要复用编解码器实例，减少频繁创建 / 销毁的性能损耗；
- 按产品隔离脚本（不同产品有不同的解析脚本）。

#### 代码示例

```csharp
using Artizan.IoT.DataCodec.Core.Models;
using Artizan.IoT.DataCodec.Core.Utils.Logging;
using Artizan.IoT.DataCodec.JavaScript.Engines;
using Artizan.IoT.DataCodec.JavaScript.Pooling.Managers;
using Microsoft.Extensions.Logging.Abstractions;
using System.Threading.Tasks;

// 1. 初始化日志
CodecLogger.Initialize(NullLogger.Instance);

// 2. 定义产品级别的JS脚本（每个产品有独立脚本）
var productKey = "temp_humi_sensor_product";
var productScript = @"
    function decode(rawData) {
        return { Temp: (rawData[0] << 8 | rawData[1]) / 10, Humi: (rawData[2] << 8 | rawData[3]) / 10 };
    }
    function encode(protocolData) {
        var data = JSON.parse(protocolData);
        return [0xAA, data.ledOn ? 0x01 : 0x00, 0x55];
    }
";

// 3. 获取对象池管理器单例
var poolManager = JavaScriptCodecPoolManager.Instance;

// 4. 获取该产品对应的编解码器对象池（池容量默认：CPU核心数×2）
var codecPool = poolManager.GetPool(productKey, productScript, maxPoolSize: 10);

// 5. 高并发场景：模拟100个设备并行解析数据
var tasks = new List<Task>();
for (int i = 0; i < 100; i++)
{
    var deviceIndex = i;
    tasks.Add(Task.Run(async () =>
    {
        // 从池中获取编解码器实例
        var jsCodec = codecPool.Get();
        try
        {
            // 占用实例（线程安全）
            if (jsCodec.TryAcquire())
            {
                // 构造设备上下文
                var context = new ScriptExecutionContext
                {
                    RawData = new byte[] { 0x01, (byte)(deviceIndex % 255), 0x02, (byte)(deviceIndex % 255) },
                    ProductKey = productKey,
                    DeviceName = $"sensor_{deviceIndex:000}",
                    MethodName = "decode"
                };

                // 执行解码
                var result = await jsCodec.DecodeAsync(context);
                if (result.Success)
                {
                    Console.WriteLine($"设备{context.DeviceName}解析结果：{result.OutputProtocolData}");
                }
                else
                {
                    Console.WriteLine($"设备{context.DeviceName}解析失败：{result.ErrorMessage}");
                }
            }
        }
        finally
        {
            // 释放实例
            jsCodec.Release();
            // 将实例归还到池中（关键：复用实例）
            codecPool.Return(jsCodec);
        }
    }));
}

await Task.WhenAll(tasks);

// 6. 产品脚本更新时，移除旧池（下次GetPool会创建新池）
poolManager.RemovePool(productKey);
```

### 3. 为什么高并发场景必须用对象池？

|   维度   |              直接创建实例（无池）               |            使用对象池             |         核心优势         |
| :------: | :---------------------------------------------: | :-------------------------------: | :----------------------: |
|   性能   | 每次创建 Jint 引擎耗时 5-10ms，高并发下性能雪崩 |    复用已有实例，创建开销为 0     |   吞吐量提升 10-100 倍   |
|   内存   |  每个实例占用～2MB 内存，1000 并发需 2GB 内存   | 池容量可控（如 10 个实例仅 20MB） |    内存占用降低 90%+     |
| 线程安全 |          需手动控制实例唯一性，易出错           | 池化实例 + 线程 ID 绑定，天然安全 |   避免多线程上下文污染   |
| 资源回收 |        GC 频繁回收，导致 STW（停止世界）        |       实例复用，GC 压力极小       | 降低 GC 频率，提升稳定性 |

**核心原理**：Jint 引擎的创建 / 初始化是重量级操作（涉及脚本编译、沙箱配置），对象池通过复用已初始化的实例，避免重复创建的性能损耗，是高并发 IoT 场景的核心优化手段。